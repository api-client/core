/* eslint-disable @typescript-eslint/no-explicit-any */
import { Jexl } from 'jexl';
import { Property } from '../../../models/Property.js';
import { IRequest } from '../../../models/Request.js';
import { mapRunnables } from '../actions/RunnableCondition.js';
import { VariablesProcessor, EvaluateOptions } from '../variables/VariablesProcessor.js';
import { ISentRequest } from '../../../models/SentRequest.js';
import { IArcResponse } from '../../../models/ArcResponse.js';
import { IErrorResponse } from '../../../models/ErrorResponse.js';
import { Action, IAction } from '../../../models/actions/Action.js';

export interface RequestProcessOptions {
  /**
   * Whether to run jexl to evaluate variables. Default to true.
   * @default true
   */
  evaluateVariables?: boolean;
  /**
   * Whether to override application variables with system variables
   * @default true
   */
  evaluateSystemVariables?: boolean;
}

export interface ResponseProcessOptions {
  /**
   * Whether to run jexl to evaluate variables. Default to true.
   * @default true
   */
  evaluateVariables?: boolean;
  /**
   * Whether to override application variables with system variables
   * @default true
   */
  evaluateSystemVariables?: boolean;
}

/**
 * The main class that executes actions for a request and a response in Advanced REST Client.
 * 
 * !!! THIS IS TODO !!!
 */
export class ActionsRunner {
  jexl: any;
  variables: Property[];

  constructor(variables: Property[]=[]) {
    this.jexl = new Jexl();
    this.variables = variables;
  }

  /**
   * Takes the ARC editor request object and runs the request actions added to it.
   * 
   * Note, actions are executed one-by-one in order defined by the `priority` property. The final request object may be changed.
   * 
   * @param request ARC request object generated by the request editor.
   * @param config Optional configuration
   * @return Promise resolved to the passed request object. It may be a copy.
   * @throws {Error} When required arguments are not set.
   */
  async processRequestActions(request: IRequest, config: RequestProcessOptions={}): Promise<IRequest> {
    if (!request) {
      throw new Error('Expected an argument.');
    }
    const { actions, expects } = request;
    if (!actions) {
      return request;
    }
    const requestActions = actions.request;
    if (!Array.isArray(requestActions)) {
      return request;
    }
    const enabled = requestActions.filter((item) => !!item.enabled && !!item.actions && !!item.actions.length);
    if (!enabled.length) {
      return request;
    }
    const runnables = mapRunnables(enabled);

    let processor: VariablesProcessor | undefined;
    let systemVariables: NodeJS.ProcessEnv | undefined;
    if (config.evaluateVariables !== false) {
      if (config.evaluateSystemVariables !== false) {
        systemVariables = process.env;
      } else {
        systemVariables = undefined;
      }
      processor = new VariablesProcessor(this.jexl, this.variables);
    } else {
      processor = undefined;
      systemVariables = undefined;
    }
    for (let i = 0, len = runnables.length; i < len; i++) {
      const runnable = runnables[i];
      if (!runnable.satisfied(expects)) {
        continue;
      }
      const execs = runnable.actions.filter((item) => !!item.enabled);
      execs.sort(Action.sortActions);
      for (let j = 0, eLen = execs.length; j < eLen; j++) {
        const action = await this.evaluateAction(execs[j], processor, systemVariables);
        console.log(action);
        
        // const runner = new ActionRunner(action, this.eventsTarget, {
        //   request: request.request,
        // });
        // if (action.sync === false) {
        //   this.runAsynchronousAction(runner);
        //   continue;
        // }
        // try {
        //   await runner.run();
        // } catch (e) {
        //   if (action.failOnError) {
        //     throw e;
        //   }
        // }
      }
    }
    return request;
  }

  // /**
  //  * Runs asynchronous action
  //  */
  // async runAsynchronousAction(runner: ActionRunner): Promise<void> {
  //   try {
  //     await runner.run();
  //   } catch (e) {
  //     // eslint-disable-next-line no-console
  //     console.info(`Asynchronous action resulted in error`, e);
  //   }
  // }

  /**
   * Processes actions when response object is ready.
   * 
   * @param {ArcEditorRequest} request ARC request object generated by the request editor.
   * @param {TransportRequest} executed The request reported by the transport library
   * @param {Response|ErrorResponse} response ARC response object.
   * @param {ResponseProcessOptions=} [config={}] Optional configuration
   * @returns {Promise<void>} A promise resolved when actions were performed.
   */
  async processResponseActions(request: IRequest, executed?: ISentRequest, response?: IArcResponse | IErrorResponse, config: ResponseProcessOptions={}): Promise<void> {
    if (!request || !executed || !response) {
      throw new Error('Expected 3 arguments.');
    }
    const { actions } = request;
    if (!actions) {
      return;
    }
    const responseActions = actions.response;
    if (!Array.isArray(responseActions)) {
      return;
    }
    const enabled = responseActions.filter((item) => !!item.enabled && !!item.actions && !!item.actions.length);
    if (!enabled.length) {
      return;
    }
    const runnables = mapRunnables(enabled);
    let processor: VariablesProcessor | undefined;
    let systemVariables: NodeJS.ProcessEnv | undefined;
    if (config.evaluateVariables !== false) {
      if (config.evaluateSystemVariables !== false) {
        systemVariables = process.env;
      } else {
        systemVariables = undefined;
      }
      processor = new VariablesProcessor(this.jexl, this.variables);
    } else {
      processor = undefined;
      systemVariables = undefined;
    }
    for (let i = 0, len = runnables.length; i < len; i++) {
      const runnable = runnables[i];
      if (!runnable.satisfied(executed, response)) {
        continue;
      }
      const execs = runnable.actions.filter((item) => !!item.enabled);
      execs.sort(Action.sortActions);
      for (let j = 0, eLen = execs.length; j < eLen; j++) {
        const action = await this.evaluateAction(execs[j], processor, systemVariables);
        console.log(action);

        // const runner = new ActionRunner(action, this.eventsTarget, {
        //   request: request.request,
        //   executedRequest: executed,
        //   response,
        // });
        // if (action.sync === false) {
        //   this.runAsynchronousAction(runner);
        //   continue;
        // }
        // try {
        //   await runner.run();
        // } catch (e) {
        //   if (action.failOnError) {
        //     throw e;
        //   }
        // }
      }
    }
  }

  /**
   * Evaluates variables in the action.
   * @param action An action to evaluate.
   * @param processor Initialized variables processor with the current environment
   * @param systemVariables System variables to use with the variables processor.
   * @return Resolved to an action without variables.
   */
  async evaluateAction(action: Action, processor?: VariablesProcessor, systemVariables?: NodeJS.ProcessEnv): Promise<IAction> {
    const copy = action.toJSON();
    if (!processor) {
      return copy;
    }
    const { config } = copy;
    if (!config) {
      return copy;
    }
    const evalOptions: EvaluateOptions = {};
    if (systemVariables) {
      const records: Record<string, string> = {};
      Object.keys(systemVariables).forEach(key => {
        const value = systemVariables[key];
        if (value) {
          records[key] = value;
        }
      });
      evalOptions.override = records;
    }

    await processor.evaluateVariables(config, evalOptions);
    const { source } = (config as any);
    if (source) {
      await processor.evaluateVariables(source, evalOptions);
      if (source.iterator) {
        await processor.evaluateVariables(source.iterator, evalOptions);
      }
    }
    return copy;
  }
}
